# Mount your Google Drive for persistent storage in Colab
from google.colab import drive
drive.mount('/content/drive')

import os
import re
import shutil
from datetime import datetime, timedelta

# --- Configuration ---
# Set the base path to the target folder on your Google Drive
base_path = "/content/drive/My Drive/Drive Code/EDI_Upload/2025/"
# Define the format for week folder names
folder_name_pattern_str = r"^Week_(\d+)_\((\d{2}\.\d{2}\.\d{2})\)_\((\d{2}\.\d{2}\.\d{2})\)$"
# Format string for creating new folder names
folder_name_format = "Week_{0}_({1})_({2})"
# Date format used in folder and file names
date_format = "%m.%d.%y"
# --- End Configuration ---

# Ensure the base path exists
os.makedirs(base_path, exist_ok=True)

def update_date_in_filename(filename, old_start_date_str, old_end_date_str, new_start_date_str, new_end_date_str):
    """Replaces old date strings with new date strings within a filename."""
    # Escape dots for regex safety
    old_start_date_pattern = re.escape(old_start_date_str)
    old_end_date_pattern = re.escape(old_end_date_str)
    # Replace old dates with new dates
    updated_filename = re.sub(old_start_date_pattern, new_start_date_str, filename)
    updated_filename = re.sub(old_end_date_pattern, new_end_date_str, updated_filename)
    return updated_filename

# Compile regex pattern for efficiency
pattern = re.compile(folder_name_pattern_str)
week_folders = []

# --- Scan Existing Week Folders ---
print(f"Scanning for existing week folders in: {base_path}")
for entry in os.listdir(base_path):
    full_path = os.path.join(base_path, entry)
    if os.path.isdir(full_path):
        m = pattern.match(entry)
        if m:
            week_number = int(m.group(1))
            start_date_str = m.group(2)
            end_date_str = m.group(3)
            week_folders.append({
                'path': full_path,
                'name': entry,
                'week_number': week_number,
                'start_date_str': start_date_str,
                'end_date_str': end_date_str
            })

# --- Find the Latest Week Folder ---
latest_folder = None
if week_folders:
    # Sort folders first by week number (desc), then by end date (desc)
    week_folders.sort(key=lambda x: (x['week_number'], datetime.strptime(x['end_date_str'], date_format)), reverse=True)
    latest_folder = week_folders[0] # The first item is the latest after sorting
    print(f"Found latest folder: {latest_folder['name']}")
else:
    print("No existing week folders found.")

# --- Calculate New Week Details ---
if latest_folder:
    # Calculate based on the latest folder found
    latest_end_date = datetime.strptime(latest_folder['end_date_str'], date_format)
    new_week_number = latest_folder['week_number'] + 1
    new_start_date = latest_end_date + timedelta(days=1)
    new_end_date = new_start_date + timedelta(days=6)
    # Store details from the latest folder needed for filename updates
    latest_folder_path = latest_folder['path']
    latest_folder_start_date_str = latest_folder['start_date_str']
    latest_folder_end_date_str = latest_folder['end_date_str']
else:
    # Initialize for the very first week (Week 1)
    print("Initializing for Week 1.")
    new_week_number = 1
    # Use current date as the start for the first week if none exist
    # Using the specific date from your original output calculation for consistency example:
    # If you want it to truly be based on today: new_start_date = datetime.now()
    # Let's assume we want to recreate the *logic* that resulted in 04.24.25 start,
    # which implies a previous end date of 04.23.25. If running today (Apr 3 2025)
    # without previous folders, it *should* be Week 1 starting 04.03.25.
    # We'll stick to the logic: Start Week 1 based on *today's* date.
    new_start_date = datetime.now()
    new_end_date = new_start_date + timedelta(days=6)
    latest_folder_path = None # No previous folder to copy from
    latest_folder_start_date_str = '' # No old dates to replace
    latest_folder_end_date_str = ''

# Format new dates as strings
new_start_date_str = new_start_date.strftime(date_format)
new_end_date_str = new_end_date.strftime(date_format)

# --- Create New Folder ---
new_folder_name = folder_name_format.format(new_week_number, new_start_date_str, new_end_date_str)
new_folder_path = os.path.join(base_path, new_folder_name)
print(f"Creating new folder: {new_folder_path}")
os.makedirs(new_folder_path, exist_ok=True)

# --- Copy Contents and Update Filenames (if applicable) ---
if latest_folder_path:
    print(f"Copying contents from {latest_folder['name']} to {new_folder_name}...")
    for dirpath, dirnames, filenames in os.walk(latest_folder_path):
        # Calculate relative path from the source base
        rel_path = os.path.relpath(dirpath, latest_folder_path)
        # Construct destination directory path
        dest_dir = os.path.join(new_folder_path, rel_path)
        # Create destination subdirectory if it doesn't exist (needed for nested folders)
        os.makedirs(dest_dir, exist_ok=True)

        for filename in filenames:
            src_file = os.path.join(dirpath, filename)
            # Update the dates in the filename if they match the old week's dates
            new_filename = update_date_in_filename(
                filename,
                latest_folder_start_date_str,
                latest_folder_end_date_str,
                new_start_date_str,
                new_end_date_str
            )
            dest_file = os.path.join(dest_dir, new_filename)
            shutil.copy2(src_file, dest_file) # copy2 preserves metadata
    print("Copying and filename update complete.")
else:
    print("No previous folder found to copy contents from.")

# --- Final Output ---
# The original script only printed one line at the end.
# This version prints progress, but we can add the final summary line back if needed.
print(f"Script finished. New folder created: {new_folder_path}")

# If you want the *exact* final print statement from the original:
# print(f"Created new folder and copied contents with updated names: {new_folder_path}")
